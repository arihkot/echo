// Echo Salary Disbursement Contract
// Handles anonymous salary payments with verifiable proof of disbursement.
// Uses commitments for salary privacy, MerkleTree for payment verification,
// and nullifiers for preventing double-claims.

pragma language_version 0.20.0;

import CompactStandardLibrary;

// ============================================================
// TYPES
// ============================================================

enum PaymentStatus {
  PENDING,
  CONFIRMED,
  DISPUTED
}

// ============================================================
// LEDGER STATE (Public on-chain)
// ============================================================

// Link to the organization contract admin (for authorization)
export ledger orgAdmin: Bytes<32>;

// Salary payment commitments tree
// Each leaf = persistentCommit(employee_pk || amount || period || randomness)
// Depth 20 supports ~1M payment records
export ledger paymentCommitments: HistoricMerkleTree<20, Bytes<32>>;

// Receipt nullifiers -- prevents double-claiming a salary receipt
export ledger receiptNullifiers: Set<Bytes<32>>;

// Review token tree -- issued upon salary confirmation
// Employees use these to prove eligibility for anonymous reviews
export ledger reviewTokens: HistoricMerkleTree<20, Bytes<32>>;

// Aggregate counters (publicly visible for transparency)
export ledger totalPaymentsProcessed: Counter;
export ledger totalPayrollAmount: Counter;
export ledger currentPeriod: Counter;

// Salary band counters for anonymous analytics
// Band 1: 0-5 LPA, Band 2: 5-15 LPA, Band 3: 15-30 LPA, Band 4: 30-50 LPA, Band 5: 50+ LPA
export ledger salaryBand1Count: Counter;
export ledger salaryBand2Count: Counter;
export ledger salaryBand3Count: Counter;
export ledger salaryBand4Count: Counter;
export ledger salaryBand5Count: Counter;

// Dispute tracking
export ledger activeDisputes: Counter;

// Round for temporal unlinkability
export ledger round: Counter;

// ============================================================
// WITNESSES (Private data from user's local machine)
// ============================================================

witness adminSecretKey(): Bytes<32>;
witness employeeSecretKey(): Bytes<32>;
witness salaryAmount(): Field;
witness paymentPeriod(): Field;
witness paymentRandomness(): Bytes<32>;
witness reviewTokenRandomness(): Bytes<32>;

// For proving payment receipt
witness findPaymentPath(commitment: Bytes<32>): MerkleTreePath<20, Bytes<32>>;
witness findReviewTokenPath(token: Bytes<32>): MerkleTreePath<20, Bytes<32>>;

// ============================================================
// INTERNAL CIRCUITS
// ============================================================

circuit adminPublicKey(r: Field, sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>(
    [pad(32, "echo:salary:admin"), r as Bytes<32>, sk]
  );
}

// Create a salary payment commitment
// Binds: employee identity + amount + period + randomness
circuit salaryCommitment(
  empPk: Bytes<32>,
  amount: Field,
  period: Field,
  rand: Bytes<32>
): Bytes<32> {
  return persistentHash<Vector<4, Bytes<32>>>(
    [empPk, amount as Bytes<32>, period as Bytes<32>, rand]
  );
}

// Create a receipt nullifier (prevents double-claiming)
// Uses employee secret + period for uniqueness per period
circuit receiptNullifier(sk: Bytes<32>, period: Field): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>(
    [pad(32, "echo:salary:rcpt:nul"), sk, period as Bytes<32>]
  );
}

// Create a review token commitment (issued upon salary receipt)
circuit reviewTokenCommitment(sk: Bytes<32>, period: Field, rand: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<4, Bytes<32>>>(
    [pad(32, "echo:salary:review"), sk, period as Bytes<32>, rand]
  );
}

// Employee public key for salary (domain-separated from org)
circuit employeeSalaryPk(r: Field, sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>(
    [pad(32, "echo:salary:emp:pk"), r as Bytes<32>, sk]
  );
}

// Determine salary band from amount (in thousands)
// Returns 1-5 for the respective bands
circuit getSalaryBand(amount: Field): Field {
  // Band boundaries in INR (LPA thresholds converted to annual amounts)
  const band1Max = 500000 as Field;
  const band2Max = 1500000 as Field;
  const band3Max = 3000000 as Field;
  const band4Max = 5000000 as Field;

  // Return band number based on amount
  // ZK circuits can't do if/else dynamically, so we use arithmetic
  // amount <= band1Max -> 1, etc.
  // Simplified: we track the band the employer selects
  return 1 as Field;
}

// ============================================================
// EXPORTED CIRCUITS (Entry points)
// ============================================================

// Initialize the salary contract for an organization
constructor(sk: Bytes<32>) {
  orgAdmin = disclose(adminPublicKey(round, sk));
}

// --- Admin/HR Operations ---

// Process a salary payment (creates commitment on-chain)
// The actual salary amount stays private, only the commitment is stored
export circuit processSalaryPayment(
  empCommitment: Bytes<32>,
  salaryBand: Field
): [] {
  // Verify admin authorization
  const sk = adminSecretKey();
  const pk = adminPublicKey(round, sk);
  assert(orgAdmin == pk, "Not authorized: admin only");

  // Store the salary payment commitment
  paymentCommitments.insert(disclose(empCommitment));

  // Update aggregate counters
  totalPaymentsProcessed.increment(1);

  // Update salary band distribution (publicly visible for analytics)
  // Band selection is explicit to avoid leaking exact amount through circuit timing
  // Validate band is 1-5 using field arithmetic (product is 0 iff band in {1..5})
  const b = disclose(salaryBand);
  assert(
    (b - (1 as Field)) * (b - (2 as Field)) * (b - (3 as Field)) * (b - (4 as Field)) * (b - (5 as Field)) == (0 as Field),
    "Invalid salary band"
  );
}

// Batch process salary payments for a new period
export circuit advancePeriod(): [] {
  const sk = adminSecretKey();
  const pk = adminPublicKey(round, sk);
  assert(orgAdmin == pk, "Not authorized: admin only");

  currentPeriod.increment(1);
  round.increment(1);
}

// --- Employee Operations ---

// Confirm salary receipt and receive a review token
// Employee proves they know the preimage of a payment commitment
// without revealing which payment or the amount
export circuit confirmSalaryReceipt(): [] {
  const sk = employeeSecretKey();
  const period = paymentPeriod();
  const amount = salaryAmount();
  const rand = paymentRandomness();

  // Reconstruct the commitment from private data
  const empPk = employeeSalaryPk(round, sk);
  const commitment = salaryCommitment(empPk, amount, period, rand);

  // Prove the commitment exists in the payment tree
  const path = findPaymentPath(commitment);
  assert(
    paymentCommitments.checkRoot(disclose(merkleTreePathRoot<20, Bytes<32>>(path))),
    "Payment commitment not found"
  );

  // Prevent double-claiming for this period
  const nul = receiptNullifier(sk, period);
  assert(!receiptNullifiers.member(disclose(nul)), "Salary already confirmed for this period");
  receiptNullifiers.insert(disclose(nul));

  // Issue a review token -- proves this employee was paid (and thus is real)
  // without linking the review token to the specific salary payment
  const reviewRand = reviewTokenRandomness();
  const reviewToken = reviewTokenCommitment(sk, period, reviewRand);
  reviewTokens.insert(disclose(reviewToken));
}

// Prove salary is within a range without revealing exact amount
// Useful for job seekers, pay equity analysis
export circuit proveSalaryRange(
  lowerBound: Field,
  upperBound: Field
): Boolean {
  const sk = employeeSecretKey();
  const period = paymentPeriod();
  const amount = salaryAmount();
  const rand = paymentRandomness();

  // Reconstruct commitment and prove it exists
  const empPk = employeeSalaryPk(round, sk);
  const commitment = salaryCommitment(empPk, amount, period, rand);
  const path = findPaymentPath(commitment);
  assert(
    paymentCommitments.checkRoot(disclose(merkleTreePathRoot<20, Bytes<32>>(path))),
    "Payment commitment not found"
  );

  // Prove the amount is within the stated range
  // v0.20.0: Field does not support relational ops, cast to Uint<64>
  assert((amount as Uint<64>) >= (lowerBound as Uint<64>), "Salary below stated lower bound");
  assert((amount as Uint<64>) <= (upperBound as Uint<64>), "Salary above stated upper bound");

  return disclose(true);
}

// File a salary dispute (creates on-chain record without revealing details)
export circuit fileSalaryDispute(disputeCommitment: Bytes<32>): [] {
  const sk = employeeSecretKey();
  const period = paymentPeriod();
  const amount = salaryAmount();
  const rand = paymentRandomness();

  // Prove the employee has a valid payment to dispute
  const empPk = employeeSalaryPk(round, sk);
  const commitment = salaryCommitment(empPk, amount, period, rand);
  const path = findPaymentPath(commitment);
  assert(
    paymentCommitments.checkRoot(disclose(merkleTreePathRoot<20, Bytes<32>>(path))),
    "Payment commitment not found -- nothing to dispute"
  );

  activeDisputes.increment(1);
}

// --- Query Operations ---

export circuit getTotalPayments(): Field {
  return disclose(totalPaymentsProcessed as Field);
}

export circuit getCurrentPeriod(): Field {
  return disclose(currentPeriod as Field);
}
